#include "AmnesiaSignatures.cpp"
#include "AmnesiaExtensions.ihps"
#include "Utilities.ihps"
#include "EveryMapEvents_AUTORUN.ihps"
#include "ForceEssentialItems_AUTORUN.ihps"
#include "Meditation.ihps"

// ============================================================================
// Main
// ============================================================================
const string gMapId = "04";

void OnStart()
{
    GetGlobalLoadingScreen(gMapId);
    RegisterCallbacks();
    AddTimer("", 0.5f, "OnMapEnterVoiceover");
    StartAmbience("ambience_hollow_tinker.snt");
    FadeOut(0.0f);
    PlayMusic("11_paper_howl.ogg");
}

void OnEnter()
{
    PlayMusic("SOTR_overlook.ogg", false, 0.5f, 0.5f, 1.0f, false);
    PreloadSound("ambience_hollow_tinker.snt");
}

void RegisterCallbacks()
{
    for(int i = 1; i <= brBookCount; i++)
    {
        AddUseItemCallback(
            "", 				/* Name */
            brBookItemBase + i, /* Item Name */
            brRitualArea, 		/* Entity */
            "PlaceRitualBook", 	/* Callback Function */
            true 				/* Destroy Item */
        );
    }

    AddSinglePlayerCollideCallback(
        "EmiliaVoiceIntro", 
        "EmiliaVoiceLine1"
    );
    AddSinglePlayerCollideCallback(
        "EmiliaConvoArea", 
        "DoorConversation"
    );
    AddSinglePlayerCollideCallback(
        "MonsterSequenceBegin", 
        "BeginMonsterSequence"
    );
    AddSinglePlayerCollideCallback(
        "EndingSequenceArea", 
        "EndingLine1"
    );
    AddSinglePlayerCollideCallback(
        "TombminderArea", 
        "LookAtFirstTomb"
    );
    AddRepeatedPlayerCollideCallback(
        "EnsureFirstTombArea",
        "EnsureFirstTombPickup"
    );
}

// ============================================================================
// VOICE ACTING
// ============================================================================

void EmiliaVoiceLine1(string a, string b, int state)
{
    PlayVoiceOnEntityAndSlowdown(
        "OL_Emilia_1.ogg", /* File */
        "EmiliaNarration", /* Subtitle: Category */
        "3",               /* Subtitle: Entry */
        "EmiliaSource"     /* Position entity */
    );
    PlayVoiceOnPlayerAndSlowdown(
        "OL_Johan_2.ogg", 
        "JohanNarration", 
        "24"
    );
    PlayVoiceOnEntityAndSlowdown(
        "OL_Emilia_2.ogg", /* File */
        "EmiliaNarration", /* Subtitle: Category */
        "4",               /* Subtitle: Entry */
        "EmiliaSource"     /* Position entity */
    );
}

void DoorConversation(string a, string b, int state)
{
    StartPlayerLookAt(
        "EmiliaSource", /* Entity */
        1.0f,            /* Multiplier */
        1.5f,            /* Max speed */
        ""               /* Callback */
    );
    SetPlayerActive(false);
    PlayVoiceOnEntityAndSlowdown(
        "OL_Emilia_3.ogg", /* File */
        "EmiliaNarration", /* Subtitle: Category */
        "5",               /* Subtitle: Entry */
        "EmiliaSource"     /* Position entity */
    );
    PlayVoiceOnEntityAndSlowdown(
        "OL_Emilia_4.ogg", /* File */
        "EmiliaNarration", /* Subtitle: Category */
        "6",               /* Subtitle: Entry */
        "EmiliaSource"     /* Position entity */
    );
    SetEffectVoiceOverCallback("DoorConversationEnd");
}

void DoorConversationEnd()
{
    PlayVoiceOnPlayerAndSlowdown(
        "OL_Johan_3.ogg", 
        "JohanNarration", 
        "25"
    );

    ResetPlayerState();
}

// Glenn Comment: When the ritual in the cellar is complete, the below line should play.
//    

// Glenn Comment: When the first grimoire is picked up, the below line should be played.
//    

// Glenn Comment: When the last grimoire is picked up, the below line should be played.
//    

// ----------------------------------------------------------------------------
// Monster Sequence Initialize
// ----------------------------------------------------------------------------

void BeginMonsterSequence(string a, string b, int state)
{
    AddEffectVoice("OL_Johan_6.ogg", "", "JohanNarration", "28", false, "player", 0.0f, 20.0f);
}


// ----------------------------------------------------------------------------
// Ending Sequence - Audio
// ----------------------------------------------------------------------------


void EndingLine1(string a, string b, int state)
{
    AddEffectVoice("OL_Johan_8.ogg", "", "JohanNarration", "30", false, "player", 0.0f, 20.0f);
}

// ----------------------------------------------------------------------------
// Book Ritual - br
// ----------------------------------------------------------------------------
const int    brBookCount        = 3;
const string brBookItemBase     = "RitualBook_";
const string brBookStaticBase   = "RitualBookStatic_";
const string brRitualArea       = "RitualBookArea";

void PlaceRitualBook(string item, string entity)
{
    RemoveItem(item);

    AddLocalVarInt("brPlacedBooks", 1);
    int currentBookNumber = GetLocalVarInt("brPlacedBooks");

    SetEntityActive(brBookStaticBase + currentBookNumber, true);
    CheckRitualCompletion();
}

void CheckRitualCompletion()
{
    if(GetLocalVarInt("brPlacedBooks") < brBookCount) return;
    OnRitualCompleted();
}

void OnRitualBookPickup(string entity)
{
    AddLocalVarInt("brPickedBooks", 1);
    int currentBookNumber = GetLocalVarInt("brPickedBooks");

    if(currentBookNumber == 1)
    {
        OnFirstBookPickup();
    }
    else if(currentBookNumber == brBookCount)
    {
        OnLastBookPickup();
    }
}

void OnRitualCompleted()
{
    StartRitualCutscene();
}

// ----------------------------------------------------------------------------
// After-Ritual Cutscene arc
// ----------------------------------------------------------------------------
const string[] arcLampsToGoOut = {
    "PointLight_10",
    "candle_floor_21",
    "candle_floor_29",
    "candle_floor_28",
    "candle_floor_26",
    "candle_floor_25",
    "candle_floor_23",
    "candle_floor_39",
    "candle_floor_40",
    "candle_floor_41",
    "candle_floor_42",
    "candle_floor_33",
    "candle_floor_34",
    "candle_floor_35",
    "candle_floor_43",
    "candle_floor_36",
    "candle_floor_37",
    "candle_floor_38"
};

const string[] arcLightsToGoOut = {
    "PointLight_10"
};

const string arcDoorToPush = "EmiliaDoor";

void StartRitualCutscene()
{
    PlayVoiceOnPlayerAndSlowdown("OL_Johan_4.ogg", "JohanNarration", "26");
    SetEffectVoiceOverCallback("OnRitualVoiceDone");
}

void OnRitualVoiceDone()
{
    for(uint i = 0; i < arcLampsToGoOut.length(); i++)
    {
        SetLampLit(
            arcLampsToGoOut[i], /* Lamp */
            false,              /* Lit */
            true                /* Use Effects */
        );
    }

    for(uint i = 0; i < arcLightsToGoOut.length(); i++)
    {
        FadeLightTo(
            arcLightsToGoOut[i],    /* Light */
            0.0f,                   /* Red */
            0.0f,                   /* Green */
            0.0f,                   /* Blue */
            1.0f,                   /* Alpha */
            -1.0f,                  /* Radius (-1 = same as previous) */
            0.5f                    /* TimeInSeconds */
        );
    }

    SetPropHealth(arcDoorToPush, 0.0f);
}

// ----------------------------------------------------------------------------
// Voiceover Lines
// ----------------------------------------------------------------------------
void OnMapEnterVoiceover(string t)
{
    FadeIn(3.0f);
    PlayVoiceOnPlayerAndSlowdown("OL_Johan_1.ogg", "JohanNarration", "23");
    SetPlayerMoveSpeedMul(0.1f);
    StartPlayerLookAt("StatueFaceArea", 0.5f, 0.6f, "");
    SetEffectVoiceOverCallback("ResetPlayerState");
    AddTimer("", 5.0f, "BasementCreaks");
}

void BasementCreaks(string t)
{
    int stage = GetLocalVarInt("BasementCreaks");
    AddLocalVarInt("BasementCreaks", 1);
    float delay = 0.0f;

    if(stage == 0)
    {
        PlaySoundAtEntity("scare_wood_creak_scuf.snt", "BigFeetArea_1");
        CreateParticleSystemAtEntityWithAlpha("ps_dust_falling_big_feet.ps", "BigFeetArea_1", 0.25f);
        delay = 4.0f;
    }
    else if(stage == 1)
    {
        PlaySoundAtEntity("scare_wood_creak_walk.snt", "BigFeetArea_2");
        CreateParticleSystemAtEntityWithAlpha("ps_dust_falling_big_feet.ps", "BigFeetArea_2", 0.25f);
        StartPlayerLookAt("BigFeetArea_2", 0.5f, 0.6f, "");
        delay = 2.0f;
    }
    else if(stage == 2)
    {
        StartPlayerLookAt("RitualBookArea", 0.5f, 0.6f, "");
    }
    else
    {
        return;
    }

    AddTimer("", delay, "BasementCreaks");
}

void LookAtFirstTomb(string a, string b, int s)
{
    StartPlayerLookAt("RitualBook_1", 0.8f, 1.5f, "");
    AddTimer("", 1.5f, "ResetPlayerStateTimer");
}

void EnsureFirstTombPickup(string a, string b, int s)
{
    if(s == CollisionState::onlyEnter)
    {
        
        AddDebugMessage("Checking for first tomb", false);
        if(GetLocalVarInt("FirstTombPickedUp") != 1)
        {
            SetSwingDoorClosed("StorageDoor_1", true, false);
            SetSwingDoorLocked("StorageDoor_1", true, false);
            SetPropStaticPhysics("StorageDoor_1", true);
            StartPlayerLookAt("RitualBook_1", 0.8f, 1.5f, "");
        }
        else
        {
            SetSwingDoorLocked("StorageDoor_1", false, false);
            SetPropStaticPhysics("StorageDoor_1", false);
            SetEntityActive("EnsureFirstTombArea", false);
        }
    }
    else
    {
        ResetPlayerState();
    }
}

void OnFirstBookPickup()
{
    SetLocalVarInt("FirstTombPickedUp", 1);
    RitualBookPickupScene();

}

const float rbSpotR = 1.0f;
const float rbSpotG = 0.62f;
const float rbSpotB = 0.017f;

const float rbPointR = 0.31f;
const float rbPointG = 0.0f;
const float rbPointB = 0.0f;

void RitualBookPickupScene(string t)
{
    int stage = GetLocalVarInt("RitualBookPickupScene");
    AddLocalVarInt("RitualBookPickupScene", 1);
    float delay = 0.0f;

    if(stage == 0)
    {
        SetEntityActive("RitualBook_1_Static", true);
        SetPlayerActive(false);
        StartPlayerLookAt("RitualBook_1_Static", 1.0f, 1.5f, "");
        FadeLightTo("rbSpot", rbSpotR, rbSpotG, rbSpotB, 1.0f, -1.0f, 0.5f);
        FadeLightTo("rbPoint", rbPointR, rbPointG, rbPointB, 1.0f, -1.0f, 0.5f);
        FadeRadialBlurTo(0.015f, 1.0f);
        FadePlayerFOVMulTo(0.1f, 0.05f);
        PlayVoiceOnPlayerAndSlowdown("OL_Johan_5.ogg", "JohanNarration", "27");
        SetEffectVoiceOverCallback("RitualBookPickupScene");
        return;
    }
    else if(stage == 1)
    {
        FadeLightTo("rbSpot", 0.0f, 0.0f, 0.0f, 1.0f, -1.0f, 0.5f);
        FadeLightTo("rbPoint", 0.0f, 0.0f, 0.0f, 1.0f, -1.0f, 0.5f);
        FadePlayerFOVMulTo(1.0f, 0.75f);
        FadeRadialBlurTo(0.0f, 0.5f);
        SetPropActiveAndFade("RitualBook_1_Static", false, 0.5f);
        delay = 1.0f;
    }
    else if(stage == 2)
    {
        ResetPlayerState();
    }
    else
    {
        return;
    }

    AddTimer("", delay, "RitualBookPickupScene");
}

void RitualBookPickupScene()
{
    RitualBookPickupScene("");
}

void OnLastBookPickup()
{
    PlayVoiceOnPlayerAndSlowdown("OL_Johan_7.ogg", "JohanNarration", "29");
}

// ----------------------------------------------------------------------------
// Example Meditation
// ----------------------------------------------------------------------------
void InitializeExampleMeditation()
{
    // Adding a debug item for the example.
    //GiveItem("DebugItem", "Puzzle", "DebugItem", "SOTR_DebugIcon.tga", 1.0f);

    // When the item is used at an entity, the meditation should start.
    AddUseItemCallback("", "SOTR_Clearsight_1", "MeditationArea2", "Meditate", true);
}

void Meditate(string item, string entity)
{
    // Passing in the area on which the player should focus
    // and a name of the function I want to trigger once
    // in meditation...
    StartMeditation(entity, "DummyMeditation");
}

void DummyMeditation(string t)
{
    // This is my function that happens when the player is
    // in meditation... I can do whatever in here.. even 
    // add timers and call other functions.

    // For an example, I'm just outputting a debug message.
    AddDebugMessage("Meditating...", false);

    // As a caller I am responsible to call the EndMeditation
    // function once my meditation is done... If I don't do that
    // I will meditate forever. Which sounds better then it 
    // actually is.
    AddTimer("", 3.0f, "EndMeditation");
}
